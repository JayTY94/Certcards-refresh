docker.md 

Docker Networking: 
User-defined Bridge provides isolation and built-in DNS for containers. Containers resolve each other by service name without manual IP configuration.
......................................
Host Network Mode
Removes network isolation; containers share host’s network stack. Pros: lower latency. Cons: port conflicts and reduced security.
......................................
Embedded DNS
Docker runs an internal DNS server on user-defined networks. Service names map to container IPs automatically.
......................................
Named Volumes
Managed by Docker, portable across hosts, easier to back up. Safer for persistent data than bind mounts.
......................................
Bind Mounts
Directly map host paths into containers. Flexible but risk permission issues and host dependency.
......................................
Dockerfile Layer Ordering
Order instructions to maximize cache reuse. Place frequently changed steps later to speed rebuilds.
......................................
COPY vs ADD
Use COPY for predictable file transfer. Use ADD only for archive auto-extraction or remote URLs (rare).
......................................
Health Check Behavior
Exit codes: 0 = healthy, 1 = unhealthy, 2 = starting. Docker marks container unhealthy but does not restart by default.
......................................
Isolation Model
Containers share the host kernel but isolate filesystem, process, and network namespaces.
......................................
Image Size Optimization
Use minimal base images (e.g., Alpine), combine RUN commands, and remove build tools after installation.
......................................
Environment Injection in Compose
Use environment: or env_file: to pass variables into containers. Dockerfile ENV sets defaults.
......................................
Networking Diagnostics
Test connectivity with docker exec  ping  or getent hosts .
......................................
Multi-Arch Images
Use docker buildx to create images for multiple architectures (e.g., linux/arm64, linux/amd64). Ensures correct platform on Raspberry Pi.
......................................
QEMU Emulation
Allows running non-native architecture images (e.g., amd64 on arm64). Trade-offs: slower performance and higher CPU usage.
......................................
Restart Policies
Configure in Compose or docker run with --restart. Common options: always, on-failure, unless-stopped. Helps recover from crashes but does not fix health check failures automatically.
......................................
Security Hardening
Drop unnecessary capabilities (cap_drop), use read_only root filesystem, and mount sensitive paths as tmpfs. Principle of least privilege.
......................................
Non-Root Containers
Set USER in Dockerfile and align volume ownership. Reduces risk of privilege escalation.
......................................
Seccomp and AppArmor
Docker applies default seccomp profile to restrict syscalls. AppArmor or SELinux adds extra isolation on Linux hosts.
......................................
Compose Profiles
Enable or disable optional services for different environments (e.g., dev vs prod) without editing the main Compose file.
......................................
Health Check Tuning
Adjust interval, timeout, retries, and start_period for slow-starting apps on ARM hardware. Prevent false negatives.
......................................
Service Discovery
Containers on user-defined networks resolve each other by name via Docker’s embedded DNS. No need for manual IP configuration.
......................................
Troubleshooting Workflow
Inspect health status (docker inspect), check logs (docker logs), exec into container to run health command, verify network connectivity.
......................................
Log Management
Use local log driver or configure json-file rotation (max-size, max-file) to prevent SD card exhaustion on Raspberry Pi.
......................................
Observability
Expose /health endpoints and metrics exporters (e.g., Prometheus) for monitoring container health and performance.
......................................
Graceful Startup
Use start_period in health checks and wait-for-it scripts to handle dependency readiness before marking healthy.
......................................
docker ps
Lists all running containers. Add -a to include stopped containers.
......................................
docker images
Displays all images available locally.
......................................
docker run -d -p 8080:80 nginx
Runs an Nginx container in detached mode, mapping host port 8080 to container port 80.
......................................
docker exec -it <container> bash
Starts an interactive shell inside a running container. Useful for debugging.
......................................
docker logs <container>
Shows stdout/stderr logs from a container. Add --tail 50 or -f to follow logs.
......................................
docker inspect <container>
Outputs detailed JSON metadata about a container, including health status and network settings.
......................................
docker build -t myimage:latest .
Builds an image from a Dockerfile in the current directory and tags it as myimage:latest.
......................................
docker-compose up -d
Starts all services defined in docker-compose.yml in detached mode.
......................................
docker network ls
Lists all Docker networks. Use docker network inspect <network> for details.
......................................
docker volume ls
Lists all Docker volumes. Use docker volume inspect <volume> to view mount points and metadata.
......................................