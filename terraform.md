Terraform identifies resources by their resource address, not by cloud provider IDs or display names. The resource address includes the resource type, name, module path, and any iteration key.
........
If a resource’s address changes, Terraform treats it as a completely different resource, even if the underlying infrastructure is identical.
........
Renaming a resource block without updating state causes Terraform to plan a destroy and recreate. Terraform cannot infer intent from configuration changes alone.
........
Moving a resource into or out of a module changes its resource address. Without state updates, Terraform assumes the old resource was removed and a new one was added.
........
Safe refactors require state manipulation, not just configuration edits. Terraform will not “figure it out” automatically.
........
terraform state mv changes Terraform’s understanding of which address owns a resource without modifying the real infrastructure. This is the primary tool for safe renames and moves.
........
terraform import is used to adopt existing infrastructure into state. It is not a refactor tool and does not preserve existing state relationships.
........
The count meta‑argument creates multiple resources using numeric indexes. These indexes shift when items are added or removed, making them unsafe for long‑lived infrastructure.
........
The for_each meta‑argument creates resources using stable keys, usually strings. These keys become part of the resource identity stored in state.
........
Switching from count to for_each without migrating state causes Terraform to recreate resources. Terraform cannot correlate numeric indexes with string keys automatically.
........
Resources created with for_each are addressed using the key value, such as resource.name["blue"]. Changing keys changes resource identity.
........
Large refactors often look dangerous because of address changes, not because infrastructure actually needs to change.
........
The .terraform.lock.hcl file records provider versions and checksums to ensure consistent behavior across machines and CI runs.
........
Deleting .terraform.lock.hcl allows Terraform to select new provider versions during initialization. Provider upgrades can change behavior without configuration changes.
........
Provider configuration defines how Terraform talks to an API and is scoped to the module where it is declared.
........
A provider alias allows multiple configurations of the same provider, such as different regions or accounts.
........
Provider aliases do not propagate automatically into child modules. Modules must be explicitly passed the provider configuration they should use.
........
If a module is not passed a provider alias, it uses the default provider. This can result in resources being created in the wrong account or region.
........
Terraform does not warn when resources are created in an unexpected account. Correct provider wiring is entirely the operator’s responsibility.
........
Workspaces manage multiple instances of the same configuration, not isolated environments.
........
Workspaces share configuration and backend settings. Applying in the wrong workspace modifies the active state without additional safeguards.
........
Using workspaces for dev, stage, and prod increases blast radius because state and configuration remain tightly coupled.
........
Strong environment isolation requires separate directories and separate state files, not just workspace discipline.
........
The create_before_destroy lifecycle rule requests replacement ordering but does not guarantee it. Dependencies or provider constraints may prevent it from working.
........
Resources referenced by other resources often cannot be replaced cleanly, even with create_before_destroy enabled.
........
Terraform may fail rather than violate dependency or uniqueness constraints. Errors during apply are often safer than forced replacement.
........
Variable typing defines contracts between modules and callers. Weak typing increases ambiguity during refactors.
........
Using object({ ... }) enforces structure and validation for complex inputs, improving long‑term maintainability.
........
Using any disables meaningful validation and makes refactors harder to reason about.
........
Local values are primarily a design and refactor safety tool, not a performance optimization.
........
Locals reduce duplicated expressions and make plans easier to review and reason about.
........
Terraform safety is not automatic. It emerges from stable addressing, explicit structure, and disciplined state management.
........
Terraform proficiency is measured by how safely you can change existing infrastructure without destruction, not by how quickly you can write new configuration.
........

If a Terraform plan shows a destroy and recreate after a simple rename, the most likely cause is a resource address change that was not accompanied by a state move. Terraform does not detect renames automatically.
........
If a plan shows all resources being recreated after switching from count to for_each, Terraform is reacting to index‑based addresses changing to key‑based addresses. Without state migration, Terraform assumes the old resources were removed.
........
If Terraform wants to destroy resources after moving them into a module, the cause is usually a module path change in the resource address. The fix is to move state, not to re‑apply.
........
If a plan shows destruction with no corresponding creates, suspect state/address mismatch rather than intentional removal. This is a common sign of an unsafe refactor.
........
If a refactor touches only locals, formatting, comments, or variable names and still produces changes, something else unintentionally altered a resource argument or address.
........
If Terraform plans to recreate resources after changing only variable types, check whether the values passed to resources changed, not just the type constraints.
........
If Terraform proposes replacing a resource even though the arguments look identical, the provider may consider one of the arguments force‑new, requiring replacement.
........
If create_before_destroy is enabled but Terraform still plans a destroy first, dependency constraints or uniqueness rules are preventing safe replacement.
........
If Terraform errors instead of replacing a resource, it is often because replacing it would violate provider or dependency constraints. Errors are safer than partial replacement.
........
If a refactor introduces unexpected destroys across many resources, check for a changed iteration key, such as modified for_each keys or reordered maps.
........
If resources are recreated after reordering a map literal, the map keys likely changed. Terraform cares about keys, not visual order.
........
If a plan changes resources after switching environments with workspaces, verify the active workspace before applying. Terraform applies to whichever workspace is currently selected.
........
If resources appear in the wrong account or region after a refactor, suspect provider alias wiring, not resource configuration.
........
If a module suddenly creates resources in an unexpected account, it is likely using the default provider because an alias was not explicitly passed.
........
If a plan looks correct locally but destructive in CI, compare provider versions and lock files. Provider drift can change behavior without code changes.
........
If Terraform plans changes after deleting .terraform.lock.hcl, provider versions may have been upgraded implicitly during initialization.
........
If a plan suddenly shows many changes after a harmless refactor, re‑run terraform plan with no changes to confirm whether the behavior is deterministic.
........
If Terraform wants to recreate resources after changing a module’s internal structure, verify whether resource addresses inside the module changed.
........
If Terraform wants to recreate resources after splitting one resource into multiple resources, expect manual state surgery to be required.
........
If Terraform plans to destroy resources you believe still exist, run terraform state list to confirm whether Terraform still thinks it owns them.
........
If Terraform refuses to apply a safe‑looking plan, the failure is often due to external constraints, not configuration errors.
........
If you feel tempted to “just apply and see what happens,” stop. Terraform executes plans literally and will not protect you from refactor mistakes.
........
If a refactor requires “just one quick apply in prod,” the refactor is not safe yet.
........
If you cannot explain why Terraform wants to destroy a resource, you should not apply the plan.
........
Refactors that change addresses are dangerous; refactors that change expressions are usually safe.
........
When Terraform behaves unexpectedly during refactors, the answer is almost always in the state file, not the configuration.
........
Terraform import block syntax is very simple. Make sure that you have a resource block for the import to go to or you use the -generate-config-out option with terraform plan.
Example
import {
  to = azurerm_ip_group.old_ip_group
  id = "/subscriptions/e4f1f240-7c87-4e7f-a12f-36553fb8721a/resourceGroups/Offshore_VDI/providers/Microsoft.Network/ipGroups/Offshore-AVD-IG"
}
........
If you have import blocks set up but no resource blocks for them to fill, you can generate new .tf files using terraform plan.

terraform plan -generate-config-out='<filename>.tf'

This will create a new file with a mostly functional resource block in it.
........
I had a typo that made terraform look for a provider that it didn't need. Because I had typed out the "to" section on an import block, I had used "azure_firewall_policy_rule_collection_group.old_rcg" instead of "azurerm_firewall_policy_rule_collection_group.old_rcg". That made terraform look for a provider called "azure" instead of "azurerm". 

import {
  id = "/subscriptions/e4f1f240-7c87-4e7f..."
  to = azure_firewall_policy_rule_collection_group.old_rcg
}
........
........
........
